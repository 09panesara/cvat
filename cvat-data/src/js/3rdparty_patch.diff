diff -u 3rdparty/buffer.js 3rdparty_edited/buffer.js
--- 3rdparty/buffer.js	2019-07-05 10:45:39.000000000 +0000
+++ 3rdparty_edited/buffer.js	2019-10-02 10:02:56.000000000 +0000
@@ -1,15 +1,15 @@
-JSMpeg.BitBuffer = (function(){ "use strict";
+module.exports = (function(){ "use strict";
 
 var BitBuffer = function(bufferOrLength, mode) {
 	if (typeof(bufferOrLength) === 'object') {
 		this.bytes = (bufferOrLength instanceof Uint8Array)
-			? bufferOrLength 
+			? bufferOrLength
 			: new Uint8Array(bufferOrLength);
 
 		this.byteLength = this.bytes.length;
 	}
 	else {
-		this.bytes = new Uint8Array(bufferOrLength || 1024*1024);	
+		this.bytes = new Uint8Array(bufferOrLength || 1024*1024);
 		this.byteLength = 0;
 	}
 
@@ -30,7 +30,7 @@
 BitBuffer.prototype.evict = function(sizeNeeded) {
 	var bytePos = this.index >> 3,
 		available = this.bytes.length - this.byteLength;
-	
+
 	// If the current index is the write position, we can simply reset both
 	// to 0. Also reset (and throw away yet unread data) if we won't be able
 	// to fit the new data in even after a normal eviction.
@@ -46,8 +46,8 @@
 		// Nothing read yet - we can't evict anything
 		return;
 	}
-	
-	// Some browsers don't support copyWithin() yet - we may have to do 
+
+	// Some browsers don't support copyWithin() yet - we may have to do
 	// it manually using set and a subarray
 	if (this.bytes.copyWithin) {
 		this.bytes.copyWithin(0, bytePos, this.byteLength);
@@ -105,14 +105,14 @@
 
 BitBuffer.prototype.appendSingleBuffer = function(buffer) {
 	buffer = buffer instanceof Uint8Array
-		? buffer 
+		? buffer
 		: new Uint8Array(buffer);
-	
+
 	this.bytes.set(buffer, this.byteLength);
 	this.byteLength += buffer.length;
 };
 
-BitBuffer.prototype.findNextStartCode = function() {	
+BitBuffer.prototype.findNextStartCode = function() {
 	for (var i = (this.index+7 >> 3); i < this.byteLength; i++) {
 		if(
 			this.bytes[i] == 0x00 &&
@@ -142,7 +142,7 @@
 	var i = (this.index+7 >> 3);
 	return (
 		i >= this.byteLength || (
-			this.bytes[i] == 0x00 && 
+			this.bytes[i] == 0x00 &&
 			this.bytes[i+1] == 0x00 &&
 			this.bytes[i+2] == 0x01
 		)
diff -u 3rdparty/decoder.js 3rdparty_edited/decoder.js
--- 3rdparty/decoder.js	2019-07-05 10:45:39.000000000 +0000
+++ 3rdparty_edited/decoder.js	2019-10-02 10:02:56.000000000 +0000
@@ -1,4 +1,4 @@
-JSMpeg.Decoder.Base = (function(){ "use strict";
+module.exports = (function(){ "use strict";
 
 var BaseDecoder = function(options) {
 	this.destination = null;
@@ -89,7 +89,7 @@
 		// to advance the decoded time manually and can instead sync it exactly
 		// to the PTS.
 		if (
-			newTimestampIndex !== -1 && 
+			newTimestampIndex !== -1 &&
 			newTimestampIndex !== this.timestampIndex
 		) {
 			this.timestampIndex = newTimestampIndex;
diff -u 3rdparty/jsmpeg.js 3rdparty_edited/jsmpeg.js
--- 3rdparty/jsmpeg.js	2019-07-05 10:45:39.000000000 +0000
+++ 3rdparty_edited/jsmpeg.js	2019-10-02 10:02:56.000000000 +0000
@@ -3,7 +3,7 @@
 
 // This sets up the JSMpeg "Namespace". The object is empty apart from the Now()
 // utility function and the automatic CreateVideoElements() after DOMReady.
-var JSMpeg = {
+module.exports = {
 
 	// The Player sets up the connections between source, demuxer, decoders,
 	// renderer and audio output. It ties everything together, is responsible
@@ -15,7 +15,7 @@
 	// the video and handles Audio unlocking on iOS. VideoElements can be
 	// created directly in HTML using the <div class="jsmpeg"/> tag.
 	VideoElement: null,
-	
+
 	// The BitBuffer wraps a Uint8Array and allows reading an arbitrary number
 	// of bits at a time. On writing, the BitBuffer either expands its
 	// internal buffer (for static files) or deletes old data (for streaming).
@@ -30,7 +30,7 @@
 	//   .established - boolean, true after connection is established
 	//   .completed - boolean, true if the source is completely loaded
 	//   .progress - float 0-1
-	Source: {}, 
+	Source: {},
 
 	// A Demuxer may sit between a Source and a Decoder. It separates the
 	// incoming raw data into Video, Audio and other Streams. API:
@@ -68,19 +68,10 @@
 	//   .stop()
 	//   .enqueuedTime - float, in seconds
 	//   .enabled - wether the output does anything upon receiving data
-	AudioOutput: {}, 
+	AudioOutput: {},
 
 	Now: function() {
-		return window.performance 
-			? window.performance.now() / 1000
-			: Date.now() / 1000;
-	},
-
-	CreateVideoElements: function() {
-		var elements = document.querySelectorAll('.jsmpeg');
-		for (var i = 0; i < elements.length; i++) {
-			new JSMpeg.VideoElement(elements[i]);
-		}
+		return Date.now() / 1000;
 	},
 
 	Fill: function(array, value) {
@@ -94,29 +85,9 @@
 		}
 	},
 
-	Base64ToArrayBuffer: function(base64) {
-		var binary =  window.atob(base64);
-		var length = binary.length;
-		var bytes = new Uint8Array(length);
-		for (var i = 0; i < length; i++)        {
-			bytes[i] = binary.charCodeAt(i);
-		}
-		return bytes.buffer;
-	},
-
-	// The build process may append `JSMpeg.WASM_BINARY_INLINED = base64data;` 
+	// The build process may append `JSMpeg.WASM_BINARY_INLINED = base64data;`
 	// to the minified source.
 	// If this property is present, jsmpeg will use the inlined binary data
 	// instead of trying to load a jsmpeg.wasm file via Ajax.
 	WASM_BINARY_INLINED: null
 };
-
-// Automatically create players for all found <div class="jsmpeg"/> elements.
-if (document.readyState === 'complete') {
-	JSMpeg.CreateVideoElements();
-}
-else {
-	document.addEventListener('DOMContentLoaded', JSMpeg.CreateVideoElements);
-}
-
-
diff -u 3rdparty/mpeg1.js 3rdparty_edited/mpeg1.js
--- 3rdparty/mpeg1.js	2019-07-05 10:45:39.000000000 +0000
+++ 3rdparty_edited/mpeg1.js	2019-10-08 07:50:38.000000000 +0000
@@ -1,19 +1,22 @@
-JSMpeg.Decoder.MPEG1Video = (function(){ "use strict";
+const BaseDecoder = require('./decoder');
+const BitBuffer = require('./buffer');
+const now = require('./jsmpeg').Now;
+const fill = require('./jsmpeg').Fill;
 
-// Inspired by Java MPEG-1 Video Decoder and Player by Zoltan Korandi 
+module.exports = (function(){ "use strict";
+
+// Inspired by Java MPEG-1 Video Decoder and Player by Zoltan Korandi
 // https://sourceforge.net/projects/javampeg1video/
 
 var MPEG1 = function(options) {
-	JSMpeg.Decoder.Base.call(this, options);
+	BaseDecoder.call(this, options);
 
 	this.onDecodeCallback = options.onVideoDecode;
 
-	var bufferSize = options.videoBufferSize || 512*1024;
-	var bufferMode = options.streaming
-		? JSMpeg.BitBuffer.MODE.EVICT
-		: JSMpeg.BitBuffer.MODE.EXPAND;
+	var bufferSize = options.videoBufferSize || 8*1024*1024;
+	var bufferMode = BitBuffer.MODE.EXPAND;
 
-	this.bits = new JSMpeg.BitBuffer(bufferSize, bufferMode);
+	this.bits = new BitBuffer(bufferSize, bufferMode);
 
 	this.customIntraQuantMatrix = new Uint8Array(64);
 	this.customNonIntraQuantMatrix = new Uint8Array(64);
@@ -23,11 +26,11 @@
 	this.decodeFirstFrame = options.decodeFirstFrame !== false;
 };
 
-MPEG1.prototype = Object.create(JSMpeg.Decoder.Base.prototype);
+MPEG1.prototype = Object.create(BaseDecoder.prototype);
 MPEG1.prototype.constructor = MPEG1;
 
 MPEG1.prototype.write = function(pts, buffers) {
-	JSMpeg.Decoder.Base.prototype.write.call(this, pts, buffers);
+	BaseDecoder.prototype.write.call(this, pts, buffers);
 
 	if (!this.hasSequenceHeader) {
 		if (this.bits.findStartCode(MPEG1.START.SEQUENCE) === -1) {
@@ -36,14 +39,15 @@
 		this.decodeSequenceHeader();
 
 		if (this.decodeFirstFrame) {
+			console.log("decodeFirstFrame");
 			this.decode();
 		}
 	}
 };
 
 MPEG1.prototype.decode = function() {
-	var startTime = JSMpeg.Now();
-	
+	var startTime = now();
+
 	if (!this.hasSequenceHeader) {
 		return false;
 	}
@@ -53,14 +57,15 @@
 		return false;
 	}
 
-	this.decodePicture();
-	this.advanceDecodedTime(1/this.frameRate);
+	const result = this.decodePicture();
+	// this.advanceDecodedTime(1/this.frameRate);
 
-	var elapsedTime = JSMpeg.Now() - startTime;
-	if (this.onDecodeCallback) {
-		this.onDecodeCallback(this, elapsedTime);
-	}
-	return true;
+	// var elapsedTime = now() - startTime;
+	// if (this.onDecodeCallback) {
+	// 	this.onDecodeCallback(this, elapsedTime);
+	// }
+
+	return result;
 };
 
 MPEG1.prototype.readHuffman = function(codeTable) {
@@ -74,7 +79,7 @@
 
 // Sequence Layer
 
-MPEG1.prototype.frameRate = 30;
+MPEG1.prototype.frameRate = 29.97;
 MPEG1.prototype.decodeSequenceHeader = function() {
 	var newWidth = this.bits.read(12),
 		newHeight = this.bits.read(12);
@@ -212,10 +217,9 @@
 		this.bits.rewind(32);
 	}
 
-	// Invoke decode callbacks
-	if (this.destination) {
-		this.destination.render(this.currentY, this.currentCr, this.currentCb, true);
-	}
+	let curY = this.currentY;
+	let curCr = this.currentCr;
+	let curCb = this.currentCb;
 
 	// If this is a reference picutre then rotate the prediction pointers
 	if (
@@ -244,6 +248,8 @@
 		this.currentCb = tmpCb;
 		this.currentCb32 = tmpCb32;
 	}
+
+	return [curY, curCr, curCb];
 };
 
 
@@ -842,7 +848,7 @@
 		else {
 			MPEG1.IDCT(this.blockData);
 			MPEG1.CopyBlockToDestination(this.blockData, destArray, destIndex, scan);
-			JSMpeg.Fill(this.blockData, 0);
+			fill(this.blockData, 0);
 		}
 	}
 	else {
@@ -854,7 +860,7 @@
 		else {
 			MPEG1.IDCT(this.blockData);
 			MPEG1.AddBlockToDestination(this.blockData, destArray, destIndex, scan);
-			JSMpeg.Fill(this.blockData, 0);
+			fill(this.blockData, 0);
 		}
 	}
 
diff -u 3rdparty/ts.js 3rdparty_edited/ts.js
--- 3rdparty/ts.js	2019-07-26 07:00:06.000000000 +0000
+++ 3rdparty_edited/ts.js	2019-10-02 10:02:56.000000000 +0000
@@ -1,4 +1,6 @@
-JSMpeg.Demuxer.TS = (function(){ "use strict";
+const BitBuffer = require('./buffer');
+
+module.exports = (function(){ "use strict";
 
 var TS = function(options) {
 	this.bits = null;
@@ -23,15 +25,14 @@
 };
 
 TS.prototype.write = function(buffer) {
-	// if (this.leftoverBytes) {
-	// 	var totalLength = buffer.byteLength + this.leftoverBytes.byteLength;
-	// 	this.bits = new JSMpeg.BitBuffer(totalLength);
-	// 	this.bits.write([this.leftoverBytes, buffer]);
-	// }
-	// else {
-	delete this.bits;
-	this.bits = new JSMpeg.BitBuffer(buffer);
-	// }
+	if (this.leftoverBytes) {
+		var totalLength = buffer.byteLength + this.leftoverBytes.byteLength;
+		this.bits = new BitBuffer(totalLength);
+		this.bits.write([this.leftoverBytes, buffer]);
+	}
+	else {
+		this.bits = new BitBuffer(buffer);
+	}
 
 	while (this.bits.has(188 << 3) && this.parsePacket()) {}
 
@@ -88,7 +89,7 @@
 			this.bits.skip(6);
 			var headerLength = this.bits.read(8);
 			var payloadBeginIndex = this.bits.index + (headerLength << 3);
-			
+
 			var pi = this.pesPacketInfo[streamId];
 			if (pi) {
 				var pts = 0;
@@ -109,14 +110,14 @@
 					// so we're using JavaScript's double number type. Also
 					// divide by the 90khz clock to get the pts in seconds.
 					pts = (p32_30 * 1073741824 + p29_15 * 32768 + p14_0)/90000;
-					
+
 					this.currentTime = pts;
 					if (this.startTime === -1) {
 						this.startTime = pts;
 					}
 				}
 
-				var payloadLength = packetLength 
+				var payloadLength = packetLength
 					? packetLength - headerLength - 3
 					: 0;
 				this.packetStart(pi, pts, payloadLength);
@@ -128,11 +129,11 @@
 
 		if (streamId) {
 			// Attempt to detect if the PES packet is complete. For Audio (and
-			// other) packets, we received a total packet length with the PES 
+			// other) packets, we received a total packet length with the PES
 			// header, so we can check the current length.
 
 			// For Video packets, we have to guess the end by detecting if this
-			// TS packet was padded - there's no good reason to pad a TS packet 
+			// TS packet was padded - there's no good reason to pad a TS packet
 			// in between, but it might just fit exactly. If this fails, we can
 			// only wait for the next PES header for that stream.
 
@@ -143,7 +144,7 @@
 
 				var hasPadding = !payloadStart && (adaptationField & 0x2);
 				if (complete || (this.guessVideoFrameEnd && hasPadding)) {
-					this.packetComplete(pi);	
+					this.packetComplete(pi);
 				}
 			}
 		}
